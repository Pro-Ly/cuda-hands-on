\section{排序}
排序算法将列表的数据元素按一定的顺序排列。 排序是现代数据和信息服务的基础，因为如果数据集顺序正确，则可以显着降低从数据集中检索信息的计算复杂性。 例如，排序通常用于规范化数据，以便在数据列表之间进行快速比较和协调。 此外，如果数据按一定顺序排列，则可以提高许多数据处理算法的效率。 由于其重要性，高效排序算法一直是许多计算机科学研究的主题。 即使使用这些高效的算法，对大型数据列表进行排序仍然很耗时，并且可以从并行执行中受益。 并行化高效排序算法具有挑战性，需要精心设计。 本章介绍两种重要的高效排序算法的并行设计：基数排序和合并排序。 本章的大部分内容致力于基数排序； 基于第 12 章“合并”中介绍的并行合并模式，简要讨论了合并排序。 还简要讨论了其他流行的并行排序算法，例如转置排序和采样排序。

\subsection{背景}

\subsection{总结}
在本章中，我们了解了如何在 GPU 上并行对键（及其关联值）进行排序。 在本章的大部分内容中，我们关注基数排序，它通过将键分布在存储桶中来对键进行排序。 对密钥中的每个数字重复分配过程，同时保留前一个数字迭代的顺序，以确保密钥根据末尾的所有数字进行排序。 每次迭代都是通过为输入列表中的每个键分配一个线程并让该线程查找输出列表中键的目的地来并行化的，这涉及与其他线程协作来执行独占扫描操作。

优化基数排序的关键挑战之一是在将键写入输出列表时实现合并内存访问。 增强合并的一个重要优化是让每个线程块对共享内存中的本地存储桶执行本地排序，然后以合并的方式将每个本地存储桶写入全局内存。 另一种优化是增加基数的大小，以减少所需的迭代次数，从而减少启动的网格数量。 但是，基数大小不应增加太多，因为这会导致较差的合并以及全局独占扫描操作的更多开销。 最后，应用线程粗化可以有效地改善内存合并以及减少全局独占扫描的开销。

基数排序的优点是计算复杂度低于 O(Nlog(N))。 但是，基数排序仅适用于有限类型的键，例如整数。 因此，我们还研究了适用于一般类型键的基于比较的排序的并行化。 一类适合并行化的基于比较的排序算法是合并排序。 合并排序可以通过并行执行不同输入段的独立合并操作以及在每个合并操作内并行化来并行化，正如我们在第 12 章“合并”中看到的那样。

在 GPU 上实现和优化并行排序算法的过程很复杂，普通用户更有可能使用 GPU 并行排序库，例如 Thrust（Bell 和 Hoberock，2012），而不是从头开始实现自己的排序内核 。 尽管如此，并行排序仍然是优化并行模式的权衡的一个有趣的案例研究。