\section{前缀和（扫描）：并行算法工作效率介绍}
我们的下一个并行模式是前缀和，通常也称为扫描。 并行扫描经常用于并行化看似顺序的操作，例如资源分配、工作分配和多项式求值。 一般来说，如果计算自然地被描述为数学递归，其中系列中的每个项目都是根据前一个项目来定义的，那么它很可能被并行化为并行扫描操作。 并行扫描在大规模并行计算中发挥着关键作用，原因很简单：应用程序的任何顺序部分都会极大地限制应用程序的整体性能。 许多这样的连续部分可以通过并行扫描转换为并行计算。 因此，并行扫描通常用作并行算法中的基本操作，执行基数排序、快速排序、字符串比较、多项式求值、求解递归、树操作和流压缩。 基数排序示例将在第 13 章“排序”中介绍。

并行扫描是一种重要的并行模式的另一个原因是，它是一些并行算法执行的工作可能比顺序算法执行的工作具有更高复杂性的典型示例，从而导致需要在 算法复杂度和并行化。 正如我们将要展示的，算法复杂性的轻微增加可能会使并行扫描比大型数据集的顺序扫描运行得更慢。 在“大数据”时代，这种考虑变得更加重要，因为海量数据集对计算复杂度较高的传统算法提出了挑战。

\subsection{背景}

\subsection{总结}
在本章中，我们研究了并行扫描，也称为前缀和，作为一种重要的并行计算模式。 扫描用于将资源并行分配给需求不一致的各方。 它将看似基于数学递归的顺序计算转换为并行计算，这有助于减少许多应用程序中的顺序瓶颈。 我们证明，简单的顺序扫描算法仅对 N 个元素的输入执行 N 2 1 或 O(N) 加法。

我们首先引入了一种并行 Kogge-Stone 分段扫描算法，该算法速度快、概念简单，但工作效率不高。 该算法执行 O (N × log2 N) 次操作，这比顺序操作要多。 随着数据集大小的增加，并行算法与简单顺序算法保持平衡所需的执行单元数量也会增加。 因此，Kogge-Stone 扫描算法通常用于在具有丰富执行资源的处理器中处理适度大小的扫描块。

然后，我们提出了一种概念上更复杂的并行 Brent-Kung 分段扫描算法。 使用归约树阶段和反向树阶段，无论输入数据集有多大，该算法都仅执行 2 × N 2 3 或 O(N) 加法。 这种操作数量随输入集大小线性增长的高效算法通常也称为数据可扩展算法。 虽然 Brent-Kung 算法比 Kogge-Stone 算法具有更好的工作效率，但需要更多步骤才能完成。 因此，在具有足够执行资源的系统中，Kogge-Stone算法尽管工作效率较低，但仍有望获得更好的性能。

我们还应用线程粗化来减轻并行扫描的硬件利用率不足和同步开销，并提高其工作效率。 通过让块中的每个线程在其自己的输入元素子部分上执行工作高效的顺序扫描来应用线程粗化，然后线程协作执行工作效率较低的块范围并行扫描以生成整个块的部分。

我们提出了一种分层扫描方法来扩展并行扫描算法以处理任意大小的输入集。 不幸的是，分段扫描算法的简单的三内核实现会产生冗余的全局内存访问，其延迟与计算不重叠。 为此，我们还提出了一种多米诺骨牌式的分层扫描算法，以实现单通道、单内核的实现，并提高分层扫描算法的全局内存访问效率。 然而，这种方法需要仔细设计使用原子操作、线程内存栅栏和屏障同步的相邻块同步机制。 还必须特别注意通过使用动态块索引分配来防止死锁。

使用例如扭曲级洗牌操作来实现更高性能的实现还有进一步的优化机会。 一般来说，在 GPU 上实现和优化并行扫描算法是复杂的过程，普通用户更有可能使用 Thrust 等 GPU 并行扫描库（Bell 和 Hoberock，2012），而不是从头开始实现自己的扫描内核。 尽管如此，并行扫描是一种重要的并行模式，它为优化并行模式的权衡提供了有趣且相关的案例研究。